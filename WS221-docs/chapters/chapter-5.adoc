== Integrating Services using Asynchronous Messaging

===  Integrating Services Using JMS

Instead of using the jms and the amqp component we're going to use just the amqp component as this is much easier to configure.

This means we don't need to provide a JmsComponent factory.

Instead we simply configure the amqp component by setting the following tree properties:

[source,properties]
----
quarkus.qpid-jms.url = amqp://localhost:5672
quarkus.qpid-jms.username = admin
quarkus.qpid-jms.password = admin
----

WARNING: Unfortunalety at the moment there is a bug in the test setup so that the tests aren't independent and cannot be run together. Instead they need to be run subsequently.

=== Guided Exercise: Integrating Services Using AMQ

5.1

Actually we only need to add one dependency:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-amqp</artifactId>
</dependency>
----

Also, we're always using the "amqp" component. So replace _jms:queue_ with _amqp:queue_ in the RouteBuilders.

The connection configuration is the easily done in the application.properties file:

[source,properties]
----
quarkus.qpid-jms.url = amqp://localhost:5672
%test.quarkus.qpid-jms.url = amqp://localhost:61616
quarkus.qpid-jms.username = admin
quarkus.qpid-jms.password = admin
----

===  Integrating Camel with Kafka

We're going to use a different test setup for this one that will be explained in the guided exercise.

As dependencies we'll only need to add one for Kafka:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-kafka</artifactId>
</dependency>
----

Config properties for Kafka in testing will be:

[source,properties]
----
camel.component.kafka.configuration.auto-offset-reset=earliest
camel.component.kafka.configuration.value-deserializer=com.redhat.training.emergency.serde.LocationDeserializer
----

=== Guided Exercise: Integrating Camel with Kafka

In contrast to the old GE we have two major differences here:

- We're only going to use the Kafka componennt, no jdbc and no mysql database (this will be done in the next chapter).
- We're using the builtin testcontainers support of Quarkus which simplifies the unit testing of various servers.

Regarding dependencies we're going to use:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-kafka</artifactId>
</dependency>
----

and for testing:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-integration-tests-support-kafka</artifactId>
    <version>2.15.0</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>kafka</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </exclusion>
    </exclusions>
</dependency>
----

To use the testcontainers-setup together with _podman_ on our workstation we need to tweek the configuration a little. First the podman socket service needs to be activated as a user service as follows (second command will show the status):

[source,bash]
----
systemctl --user enable --now podman.socket
systemctl status podman.socket
----

Additionally the following variables need to be set in the shell running the tests. This is best added to _.bashrc_:

[source,bash]
----
export DOCKER_HOST=unix:///run/user/$UID/podman/podman.sock
export TESTCONTAINERS_RYUK_DISABLED=true
----

On a system running dockerd as probably on you own development systems nothing needs to be tweeked.

In our example we're just forwarding the data to a log output and then replace the log route with:

[source,java]
----
route.interceptSendToEndpoint("direct:logger")
    .skipSendToOriginalEndpoint()
    .to("mock:file:logger");
----

So we can test the forwarding of the messages.

