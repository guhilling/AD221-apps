= Chapter 6

==  Implementing Transactions

Configuring datasources can be configured in Quarkus similar to Spring Boot:

[source,properties]
----
%prod.quarkus.datasource.db-kind=mysql
%prod.quarkus.datasource.username=quarkus_test
%prod.quarkus.datasource.password=quarkus_test
%prod.quarkus.datasource.jdbc.url=jdbc:mysql://localhost/quarkus_test?createDatabaseIfNotExist=true&autoReconnect=true&allowPublicKeyRetrieval=true&useSSL=false&?TC_INITSCRIPT=file:src/main/resources/import.sql
%prod.quarkus.datasource.jdbc.max-size=8
%prod.quarkus.datasource.jdbc.min-size=2
----

To enable testing, we add the following (see also next GE):

[source,properties]
----
quarkus.hibernate-orm.database.generation=drop-and-create
quarkus.hibernate-orm.log.sql=true
quarkus.hibernate-orm.sql-load-script=import.sql
----

The required components (when using mysql) in Camel Quarkus are:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-jdbc-mysql</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-jpa</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-sql</artifactId>
</dependency>
----

In the JPA Component the _consumer.delay_ parameter is no longer supported, instead we're going to use _initialDelay_.

=== Guided Exercise: Accessing Databases in Camel Routes

We'll use testcontainers to implement the testing, so the pom.xml contains:

[source,xml]
----
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>testcontainers</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>mysql</artifactId>
    <version>1.15.3</version>
    <scope>test</scope>
</dependency>
----

The test lifecycle will be handled automatically.
We're actually only running the unis tests for this GE so we don't need to setup a "real" database at all.

6.1)

The jpa endpoint needs to be configured as follows:
[source,java]
----
from("jpa:com.redhat.training.payments.Payment?"
        + "persistenceUnit=mysql"
        + "&consumeDelete=false"
        + "&maximumResults=5"
        + "&initialDelay=100"
        + "&runLoggingLevel=INFO"
        + "&consumeLockEntity=false")
    .log("${body}")
    .process(new PaymentFraudAnalyzer())
    .to("sql:update payment_analysis "
        + "set fraud_score =:#${headers.fraudScore}, analysis_status = 'Completed' "
        + "where payment_id=:#${body.id}")
    .to("direct:payment_analysis_complete?failIfNoConsumers=false&block=false");
----

===  Developing Transactional Routes

In Camel Quarkus it should be enough to add the JTA component on-top of the other components (see also https://access.redhat.com/solutions/6989211)

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-jta</artifactId>
</dependency>
----

The default propagation schemes are available without any extra configuration.

In the following GE not all test cases will be working as expected due to timing issues with the test setup (we'll create an artemis instance to debug this).

=== Guided Exercise: Developing Transactional Routes

Adding any containers is not really necessary except if we want to test the jms features of the appcliation/routes.

Instead we will create a test database as in the previous lab.

Creating the TransactionPolicy is not necessary in our case.

The two "failure tests" are disables because intercepting the delivery to dead-letter doesn't work as expected. We can test this by creating a proper artemis instance and then checking the message count in the queues.
